name: üöÄ Deploy Zerotier Sidecar
on:
  push:
    branches:
      - main
      - gateway
    # –ò—Å–∫–ª—é—á–∞–µ–º push —Ç–µ–≥–æ–≤ —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Ü–∏–∫–ª–æ–≤
    tags-ignore:
      - '**'
  # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ: —Ä—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫ —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é —É–∫–∞–∑–∞—Ç—å –≤–µ—Ä—Å–∏—é
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version increment type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - custom
      custom_version:
        description: 'Custom version (only if custom selected, format: v1.2.3)'
        required: false

permissions:
  contents: write
  actions: read

jobs:
  deploy:
    runs-on: self-hosted
    # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–ø—É—Å–∫ –µ—Å–ª–∏ –∫–æ–º–º–∏—Ç —Å–¥–µ–ª–∞–Ω –±–æ—Ç–æ–º GitHub Actions
    if: github.actor != 'github-actions[bot]'
    
    steps:
      - name: üß© Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîç Check if Docker rebuild needed
        id: docker_check
        run: |
          echo "Checking if Docker-related files changed..."

          # –§–∞–π–ª—ã, –∏–∑–º–µ–Ω–µ–Ω–∏–µ –∫–æ—Ç–æ—Ä—ã—Ö —Ç—Ä–µ–±—É–µ—Ç –ø–µ—Ä–µ—Å–±–æ—Ä–∫–∏ Docker –æ–±—Ä–∞–∑–∞
          DOCKER_FILES=(
            "Dockerfile"
            "docker-compose.yml"
            "start-sidecar.sh"
            ".env.example"
          )

          # –ü—Ä–∏ —Ä—É—á–Ω–æ–º –∑–∞–ø—É—Å–∫–µ –≤—Å–µ–≥–¥–∞ –ø–µ—Ä–µ—Å–æ–±–∏—Ä–∞–µ–º
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "‚úÖ Manual trigger - will rebuild Docker image"
            echo "should_build=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # –î–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ push - –ø—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ç–µ–∫—É—â–µ–º –∫–æ–º–º–∏—Ç–µ
          echo "Checking files changed in current push..."

          # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∏–∑–º–µ–Ω–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –≤ –ø–æ—Å–ª–µ–¥–Ω–µ–º –∫–æ–º–º–∏—Ç–µ
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git diff --name-only HEAD)

          if [ -z "$CHANGED_FILES" ]; then
            echo "‚ö†Ô∏è Cannot determine changed files - will rebuild to be safe"
            echo "should_build=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Changed files in this push:"
          echo "$CHANGED_FILES"
          echo ""

          # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ Docker-—Ñ–∞–π–ª–∞—Ö
          DOCKER_CHANGED=false
          for file in "${DOCKER_FILES[@]}"; do
            if echo "$CHANGED_FILES" | grep -q "^${file}$"; then
              echo "‚úÖ Changed: $file"
              DOCKER_CHANGED=true
            fi
          done

          # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å–ª–∏ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å –¢–û–õ–¨–ö–û —Ñ–∞–π–ª—ã –∏–∑ .github/ –∏–ª–∏ README - –Ω–µ –±–∏–ª–¥–∏–º
          NON_IGNORED_FILES=$(echo "$CHANGED_FILES" | grep -v "^\.github/" | grep -v "^README" | grep -v "^\.gitignore$" || true)

          if [ -z "$NON_IGNORED_FILES" ]; then
            echo "‚ÑπÔ∏è Only documentation/workflow files changed - skipping build"
            echo "   Changed files: $(echo "$CHANGED_FILES" | tr '\n' ', ')"
            echo "should_build=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$DOCKER_CHANGED" = "true" ]; then
            echo "‚úÖ Docker-related files changed - will rebuild"
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No Docker-related files changed - skipping build"
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi

      - name: üìã Early exit if no build needed
        if: steps.docker_check.outputs.should_build == 'false'
        run: |
          echo "üéâ Workflow completed - no Docker build needed"
          echo ""
          echo "‚ÑπÔ∏è Changed files don't affect the Docker image"
          echo "   No version tags or Docker builds will be created"
          echo ""
          echo "üí° To force a build, manually trigger this workflow"
          exit 0

      - name: üîë Setup Git config
        if: steps.docker_check.outputs.should_build == 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: üß† Set environment
        if: steps.docker_check.outputs.should_build == 'true'
        id: vars
        run: |
          BRANCH="${GITHUB_REF_NAME}"
          echo "Branch detected: $BRANCH"
          if [ "$BRANCH" = "main" ]; then
            BASE_TAG="latest"
            IS_RELEASE_BRANCH=true
            IS_PRERELEASE=false
            PRODUCT_NAME="ZeroTier Sidecar Core"
          elif [ "$BRANCH" = "gateway" ]; then
            BASE_TAG="gateway"
            IS_RELEASE_BRANCH=true
            IS_PRERELEASE=false
            PRODUCT_NAME="ZeroTier Sidecar Gateway"
          else
            BASE_TAG="dev"
            IS_RELEASE_BRANCH=false
            IS_PRERELEASE=true
            PRODUCT_NAME="ZeroTier Sidecar Dev"
          fi
          echo "base_tag=$BASE_TAG" >> $GITHUB_OUTPUT
          echo "is_release_branch=$IS_RELEASE_BRANCH" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          echo "product_name=$PRODUCT_NAME" >> $GITHUB_OUTPUT
          echo "Base tag: $BASE_TAG"
          echo "Is release branch: $IS_RELEASE_BRANCH"
          echo "Is prerelease: $IS_PRERELEASE"
          echo "Product: $PRODUCT_NAME"
          
      - name: üì¶ Determine version strategy
        if: steps.docker_check.outputs.should_build == 'true'
        id: version_strategy
        run: |
          set -e
          
          echo "=== DEBUG INPUTS ==="
          echo "Event name: ${{ github.event_name }}"
          echo "Version type input: '${{ github.event.inputs.version_type }}'"
          echo "Custom version input: '${{ github.event.inputs.custom_version }}'"
          
          # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION_TYPE="${{ github.event.inputs.version_type }}"
            CUSTOM_VERSION="${{ github.event.inputs.custom_version }}"
            echo "Manual trigger with version type: $VERSION_TYPE"
            if [ "$VERSION_TYPE" = "custom" ]; then
              echo "Custom version specified: $CUSTOM_VERSION"
              if [ -z "$CUSTOM_VERSION" ]; then
                echo "WARNING: Custom version is empty!"
              fi
            fi
          else
            # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π push - –≤—Å–µ–≥–¥–∞ patch increment
            VERSION_TYPE="patch"
            CUSTOM_VERSION=""
            echo "Automatic push trigger - using patch increment"
          fi
          
          echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT
          echo "custom_version=$CUSTOM_VERSION" >> $GITHUB_OUTPUT
          echo "Final outputs - version_type: $VERSION_TYPE, custom_version: $CUSTOM_VERSION"
          
      - name: üìä Calculate version
        if: steps.docker_check.outputs.should_build == 'true'
        id: version
        run: |
          set -e
          echo "Calculating version..."
          
          BRANCH="${GITHUB_REF_NAME}"
          
          # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–µ—Ñ–∏–∫—Å –≤–µ—Ä—Å–∏–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –≤–µ—Ç–æ–∫
          if [ "$BRANCH" = "main" ]; then
            VERSION_PREFIX="v1"
            TAG_PATTERN="v1.*"
          elif [ "$BRANCH" = "gateway" ]; then
            VERSION_PREFIX="v2"
            TAG_PATTERN="v2.*"
          else
            VERSION_PREFIX="v0"
            TAG_PATTERN="v0.*"
          fi
          
          echo "Branch: $BRANCH, Version prefix: $VERSION_PREFIX"
          
          # DEBUG: –ü—Ä–æ–≤–µ—Ä—è–µ–º inputs –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ step
          VERSION_TYPE="${{ steps.version_strategy.outputs.version_type }}"
          CUSTOM_VERSION="${{ steps.version_strategy.outputs.custom_version }}"
          echo "=== VERSION CALCULATION DEBUG ==="
          echo "Received version_type: '$VERSION_TYPE'"
          echo "Received custom_version: '$CUSTOM_VERSION'"
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º custom —Å—Ä–∞–∑—É
          if [ "$VERSION_TYPE" = "custom" ]; then
            if [ -z "$CUSTOM_VERSION" ]; then
              echo "‚ùå Custom version not provided"
              exit 1
            fi
            echo "Using custom version: $CUSTOM_VERSION"
            echo "version=$CUSTOM_VERSION" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –°–¢–ê–ë–ò–õ–¨–ù–´–ô —Ç–µ–≥ –¥–ª—è —Ç–µ–∫—É—â–µ–π –≤–µ—Ç–∫–∏ (–±–µ–∑ -beta, -alpha, -rc)
          # –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–≥–∏ –±–µ–∑ —Å—É—Ñ—Ñ–∏–∫—Å–æ–≤
          LAST_TAG=$(git tag --list "$TAG_PATTERN" | grep -v '\-' | sort -V | tail -n 1)

          if [ -z "$LAST_TAG" ]; then
            echo "No stable tags found for pattern $TAG_PATTERN, starting with ${VERSION_PREFIX}.0.0"
            NEW_VERSION="${VERSION_PREFIX}.0.0"
          else
            echo "Last stable tag found for branch: $LAST_TAG"
            
            # –ü–∞—Ä—Å–∏–º –≤–µ—Ä—Å–∏—é (—É–±–∏—Ä–∞–µ–º —Å—É—Ñ—Ñ–∏–∫—Å—ã —Ç–∏–ø–∞ -beta, -alpha, -rc1)
            CLEAN_VERSION="${LAST_TAG#v}"                    # –£–±–∏—Ä–∞–µ–º 'v'
            CLEAN_VERSION="${CLEAN_VERSION%%-*}"             # –£–±–∏—Ä–∞–µ–º –≤—Å—ë –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ '-'
            IFS='.' read -r MAJOR MINOR PATCH <<<"$CLEAN_VERSION"
            echo "Current version: MAJOR=$MAJOR, MINOR=$MINOR, PATCH=$PATCH (from $LAST_TAG)"
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–æ–≤—É—é –≤–µ—Ä—Å–∏—é
            case $VERSION_TYPE in
              "minor")
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              "patch")
                PATCH=$((PATCH + 1))
                ;;
              *)
                echo "‚ùå Unknown version type: $VERSION_TYPE"
                exit 1
                ;;
            esac
            
            NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          fi
          
          echo "New version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          
      - name: üè∑Ô∏è Check if release needed
        if: steps.docker_check.outputs.should_build == 'true'
        id: release_check
        run: |
          IS_RELEASE_BRANCH="${{ steps.vars.outputs.is_release_branch }}"
          VERSION_TYPE="${{ steps.version_strategy.outputs.version_type }}"
          EVENT_NAME="${{ github.event_name }}"
          SHOULD_CREATE_RELEASE="false"

          echo "=== RELEASE CHECK ==="
          echo "Event: $EVENT_NAME"
          echo "Version type: $VERSION_TYPE"
          echo "Is release branch: $IS_RELEASE_BRANCH"

          # GitHub Release —Å–æ–∑–¥–∞–µ—Ç—Å—è –¢–û–õ–¨–ö–û –¥–ª—è minor –≤–µ—Ä—Å–∏–π –ø—Ä–∏ —Ä—É—á–Ω–æ–º –∑–∞–ø—É—Å–∫–µ
          if [ "$EVENT_NAME" = "workflow_dispatch" ] && [ "$VERSION_TYPE" = "minor" ]; then
            if [ "$IS_RELEASE_BRANCH" = "true" ]; then
              SHOULD_CREATE_RELEASE="true"
              echo "‚úÖ Will create GitHub Release (manual minor version)"
            else
              echo "‚ö†Ô∏è Not a release branch - skipping release"
            fi
          else
            echo "‚ÑπÔ∏è No GitHub Release (only for manual minor versions)"
            echo "   - Event: $EVENT_NAME (need: workflow_dispatch)"
            echo "   - Version type: $VERSION_TYPE (need: minor)"
          fi

          echo "should_create_release=$SHOULD_CREATE_RELEASE" >> $GITHUB_OUTPUT
          
      - name: üìù Generate release body
        if: steps.docker_check.outputs.should_build == 'true' && steps.release_check.outputs.should_create_release == 'true'
        id: release_body
        run: |
          echo "Generating release body for minor version..."

          # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –∫–æ–º–º–∏—Ç
          LAST_COMMIT_SUBJECT=$(git log -1 --pretty=format:"%s")
          LAST_COMMIT_BODY=$(git log -1 --pretty=format:"%b")
          LAST_COMMIT_FULL=$(git log -1 --pretty=format:"%B")

          # –°—á–∏—Ç–∞–µ–º —Å—Ç—Ä–æ–∫–∏ –≤ –ø–æ–ª–Ω–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏ –∫–æ–º–º–∏—Ç–∞
          COMMIT_LINES=$(echo "$LAST_COMMIT_FULL" | wc -l | tr -d ' ')

          echo "Last commit subject: $LAST_COMMIT_SUBJECT"
          echo "Last commit lines: $COMMIT_LINES"

          # –ü—Ä–æ–≤–µ—Ä—è–µ–º —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ Release Note
          # –£—Å–ª–æ–≤–∏—è: >10 —Å—Ç—Ä–æ–∫ –ò —Å–æ–¥–µ—Ä–∂–∏—Ç markdown –∑–∞–≥–æ–ª–æ–≤–∫–∏ –∏–ª–∏ —Å–ø–∏—Å–∫–∏ —Å —ç–º–æ–¥–∑–∏
          IS_RELEASE_NOTE=false
          if [ "$COMMIT_LINES" -gt 10 ]; then
            if echo "$LAST_COMMIT_FULL" | grep -qE '^(#{1,3} |[-*] |[‚úÖ‚ùåüéØüöÄüêõüìöüîÑüéâ‚ú®üîßüê≥‚öôÔ∏èüìã])'; then
              IS_RELEASE_NOTE=true
              echo "‚úÖ Detected release note in last commit (${COMMIT_LINES} lines, contains markdown)"
            else
              echo "‚ÑπÔ∏è Last commit has ${COMMIT_LINES} lines but no markdown formatting"
            fi
          else
            echo "‚ÑπÔ∏è Last commit is too short (${COMMIT_LINES} lines) - not a release note"
          fi

          # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω —Ç–µ–≥–æ–≤ –¥–ª—è changelog
          BRANCH="${GITHUB_REF_NAME}"
          if [ "$BRANCH" = "main" ]; then
            TAG_PATTERN="v1.*"
          elif [ "$BRANCH" = "gateway" ]; then
            TAG_PATTERN="v2.*"
          else
            TAG_PATTERN="v0.*"
          fi

          # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º changelog (–∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ —Å—Ç–∞–±–∏–ª—å–Ω—ã–µ —Ç–µ–≥–∏ –±–µ–∑ —Å—É—Ñ—Ñ–∏–∫—Å–æ–≤)
          LAST_TAG=$(git tag --list "$TAG_PATTERN" | grep -v '\-' | sort -V | tail -n 1)
          if [ -z "$LAST_TAG" ]; then
            echo "No previous stable tags found for pattern $TAG_PATTERN - generating full changelog"
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges | head -50)
          else
            echo "Generating changelog since stable tag $LAST_TAG"
            CHANGELOG=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          fi

          if [ -z "$CHANGELOG" ]; then
            CHANGELOG="- No changes"
          fi

          # –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–∞
          PRODUCT_NAME="${{ steps.vars.outputs.product_name }}"
          VERSION="${{ steps.version.outputs.version }}"

          # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–ª–æ —Ä–µ–ª–∏–∑–∞
          if [ "$IS_RELEASE_NOTE" = "true" ]; then
            # –í–∞—Ä–∏–∞–Ω—Ç A: Release Note + Changelog
            echo "Using release note from commit + changelog"
            {
              echo "$LAST_COMMIT_FULL"
              echo ""
              echo "---"
              echo ""
              echo "## üìã Changelog"
              echo ""
              echo "$CHANGELOG"
            } > /tmp/release_body.txt
          else
            # –í–∞—Ä–∏–∞–Ω—Ç B: –¢–æ–ª—å–∫–æ Changelog
            echo "Using auto-generated changelog only"
            {
              echo "## ${PRODUCT_NAME} ${VERSION}"
              echo ""
              echo "## üìã Changelog"
              echo ""
              echo "$CHANGELOG"
            } > /tmp/release_body.txt
          fi

          # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è
          {
            echo "RELEASE_BODY<<EOF"
            cat /tmp/release_body.txt
            echo "EOF"
          } >> $GITHUB_ENV

          echo "‚úÖ Release body generated successfully"

      - name: üßæ Show info
        if: steps.docker_check.outputs.should_build == 'true'
        run: |
          echo "Branch: ${{ github.ref_name }}"
          echo "Base tag: ${{ steps.vars.outputs.base_tag }}"
          echo "Version: ${{ steps.version.outputs.version }}"
          echo "Is release branch: ${{ steps.vars.outputs.is_release_branch }}"
          echo "Should create release: ${{ steps.release_check.outputs.should_create_release }}"
          echo "Should build Docker: ${{ steps.docker_check.outputs.should_build }}"
          echo "Actor: ${{ github.actor }}"
          echo "Event: ${{ github.event_name }}"
          
      - name: üîê Login to Docker Hub
        if: steps.docker_check.outputs.should_build == 'true'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: üîß Build & Push Docker
        if: steps.docker_check.outputs.should_build == 'true'
        run: |
          echo "Building Docker image:"
          echo " - alexbic/zerotier-sidecar:${{ steps.vars.outputs.base_tag }}"
          echo " - alexbic/zerotier-sidecar:${{ steps.version.outputs.version }}"
          docker buildx build \
            --platform linux/amd64 \
            -t alexbic/zerotier-sidecar:${{ steps.vars.outputs.base_tag }} \
            -t alexbic/zerotier-sidecar:${{ steps.version.outputs.version }} \
            --push .

      - name: üè∑Ô∏è Create Git Tag
        if: steps.docker_check.outputs.should_build == 'true'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          echo "Creating git tag: $VERSION"

          # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ —Ç–µ–≥
          if git rev-parse "$VERSION" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è Tag $VERSION already exists, skipping tag creation"
          else
            git tag "$VERSION"
            git push origin "$VERSION"
            echo "‚úÖ Tag $VERSION created and pushed"
          fi

      - name: üéØ Create GitHub Release
        if: steps.docker_check.outputs.should_build == 'true' && steps.release_check.outputs.should_create_release == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: "${{ steps.vars.outputs.product_name }} ${{ steps.version.outputs.version }}"
          body: |
            ${{ env.RELEASE_BODY }}

            ---

            ## üê≥ Docker Images
            - `alexbic/zerotier-sidecar:${{ steps.vars.outputs.base_tag }}`
            - `alexbic/zerotier-sidecar:${{ steps.version.outputs.version }}`

            ---
            *This release was automatically generated by GitHub Actions*
          draft: false
          prerelease: ${{ steps.vars.outputs.is_prerelease }}
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: ‚úÖ Summary
        if: steps.docker_check.outputs.should_build == 'true'
        run: |
          echo "üéâ Deployment completed successfully!"
          echo ""
          echo "üì¶ Docker images pushed:"
          echo "   - alexbic/zerotier-sidecar:${{ steps.vars.outputs.base_tag }}"
          echo "   - alexbic/zerotier-sidecar:${{ steps.version.outputs.version }}"
          echo ""
          echo "üè∑Ô∏è Git tag created: ${{ steps.version.outputs.version }}"
          echo ""

          if [ "${{ steps.release_check.outputs.should_create_release }}" = "true" ]; then
            echo "‚úÖ GitHub Release created: ${{ steps.version.outputs.version }}"
            echo "üîó View release: https://github.com/${{ github.repository }}/releases/tag/${{ steps.version.outputs.version }}"
          else
            VERSION_TYPE="${{ steps.version_strategy.outputs.version_type }}"
            EVENT_NAME="${{ github.event_name }}"
            echo "‚ÑπÔ∏è No GitHub Release created"
            echo "   Reason: Only minor versions create releases"
            echo "   Current: event=$EVENT_NAME, version_type=$VERSION_TYPE"
            echo ""
            echo "üí° To create a release:"
            echo "   1. Go to Actions ‚Üí Deploy Zerotier Sidecar ‚Üí Run workflow"
            echo "   2. Select 'minor' as version type"
          fi
