name: üöÄ Deploy Zerotier Sidecar
on:
  push:
    branches:
      - main
      - gateway
    # –ò—Å–∫–ª—é—á–∞–µ–º push —Ç–µ–≥–æ–≤ —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Ü–∏–∫–ª–æ–≤
    tags-ignore:
      - '**'
  # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ: —Ä—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫ —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é —É–∫–∞–∑–∞—Ç—å –≤–µ—Ä—Å–∏—é
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version increment type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - custom
      custom_version:
        description: 'Custom version (only if custom selected, format: v1.2.3)'
        required: false
      release_notes:
        description: 'Custom release notes (Markdown). If empty, will use commit message or auto-generate changelog'
        required: false
        type: string

permissions:
  contents: write
  actions: read
  packages: write

jobs:
  deploy:
    runs-on: self-hosted
    # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–ø—É—Å–∫ –µ—Å–ª–∏ –∫–æ–º–º–∏—Ç —Å–¥–µ–ª–∞–Ω –±–æ—Ç–æ–º GitHub Actions
    if: github.actor != 'github-actions[bot]'
    
    steps:
      - name: üß© Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîç Check if Docker rebuild needed
        id: docker_check
        run: |
          echo "Checking if Docker-related files changed..."

          # –§–∞–π–ª—ã, –∏–∑–º–µ–Ω–µ–Ω–∏–µ –∫–æ—Ç–æ—Ä—ã—Ö —Ç—Ä–µ–±—É–µ—Ç –ø–µ—Ä–µ—Å–±–æ—Ä–∫–∏ Docker –æ–±—Ä–∞–∑–∞
          DOCKER_FILES=(
            "Dockerfile"
            "start-sidecar.sh"
          )

          # –ü—Ä–∏ —Ä—É—á–Ω–æ–º –∑–∞–ø—É—Å–∫–µ –≤—Å–µ–≥–¥–∞ –ø–µ—Ä–µ—Å–æ–±–∏—Ä–∞–µ–º
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "‚úÖ Manual trigger - will rebuild Docker image"
            echo "should_build=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # –î–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ push - –ø—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ç–µ–∫—É—â–µ–º –∫–æ–º–º–∏—Ç–µ
          echo "Checking files changed in current push..."

          # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∏–∑–º–µ–Ω–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –≤ –ø–æ—Å–ª–µ–¥–Ω–µ–º –∫–æ–º–º–∏—Ç–µ
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git diff --name-only HEAD)

          if [ -z "$CHANGED_FILES" ]; then
            echo "‚ö†Ô∏è Cannot determine changed files - will rebuild to be safe"
            echo "should_build=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Changed files in this push:"
          echo "$CHANGED_FILES"
          echo ""

          # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ Docker-—Ñ–∞–π–ª–∞—Ö
          DOCKER_CHANGED=false
          for file in "${DOCKER_FILES[@]}"; do
            if echo "$CHANGED_FILES" | grep -q "^${file}$"; then
              echo "‚úÖ Changed: $file"
              DOCKER_CHANGED=true
            fi
          done

          # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å–ª–∏ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å –¢–û–õ–¨–ö–û —Ñ–∞–π–ª—ã –∏–∑ .github/ –∏–ª–∏ README - –Ω–µ –±–∏–ª–¥–∏–º
          NON_IGNORED_FILES=$(echo "$CHANGED_FILES" | grep -v "^\.github/" | grep -v "^README" | grep -v "^\.gitignore$" || true)

          if [ -z "$NON_IGNORED_FILES" ]; then
            echo "‚ÑπÔ∏è Only documentation/workflow files changed - skipping build"
            echo "   Changed files: $(echo "$CHANGED_FILES" | tr '\n' ', ')"
            echo "should_build=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$DOCKER_CHANGED" = "true" ]; then
            echo "‚úÖ Docker-related files changed - will rebuild"
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No Docker-related files changed - skipping build"
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi

      - name: üìã Early exit if no build needed
        if: steps.docker_check.outputs.should_build == 'false'
        run: |
          echo "üéâ Workflow completed - no Docker build needed"
          echo ""
          echo "‚ÑπÔ∏è Changed files don't affect the Docker image"
          echo "   No version tags or Docker builds will be created"
          echo ""
          echo "üí° To force a build, manually trigger this workflow"
          exit 0

      - name: üîë Setup Git config
        if: steps.docker_check.outputs.should_build == 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: üß† Set environment
        if: steps.docker_check.outputs.should_build == 'true'
        id: vars
        run: |
          BRANCH="${GITHUB_REF_NAME}"
          echo "Branch detected: $BRANCH"
          if [ "$BRANCH" = "main" ]; then
            BASE_TAG="latest"
            IS_RELEASE_BRANCH=true
            IS_PRERELEASE=false
            PRODUCT_NAME="ZeroTier Sidecar Core"
          elif [ "$BRANCH" = "gateway" ]; then
            BASE_TAG="gateway"
            IS_RELEASE_BRANCH=true
            IS_PRERELEASE=false
            PRODUCT_NAME="ZeroTier Sidecar Gateway"
          else
            BASE_TAG="dev"
            IS_RELEASE_BRANCH=false
            IS_PRERELEASE=true
            PRODUCT_NAME="ZeroTier Sidecar Dev"
          fi
          echo "base_tag=$BASE_TAG" >> $GITHUB_OUTPUT
          echo "is_release_branch=$IS_RELEASE_BRANCH" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          echo "product_name=$PRODUCT_NAME" >> $GITHUB_OUTPUT
          echo "Base tag: $BASE_TAG"
          echo "Is release branch: $IS_RELEASE_BRANCH"
          echo "Is prerelease: $IS_PRERELEASE"
          echo "Product: $PRODUCT_NAME"
          
      - name: üì¶ Determine version strategy
        if: steps.docker_check.outputs.should_build == 'true'
        id: version_strategy
        run: |
          set -e
          
          echo "=== DEBUG INPUTS ==="
          echo "Event name: ${{ github.event_name }}"
          echo "Version type input: '${{ github.event.inputs.version_type }}'"
          echo "Custom version input: '${{ github.event.inputs.custom_version }}'"
          
          # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION_TYPE="${{ github.event.inputs.version_type }}"
            CUSTOM_VERSION="${{ github.event.inputs.custom_version }}"
            echo "Manual trigger with version type: $VERSION_TYPE"
            if [ "$VERSION_TYPE" = "custom" ]; then
              echo "Custom version specified: $CUSTOM_VERSION"
              if [ -z "$CUSTOM_VERSION" ]; then
                echo "WARNING: Custom version is empty!"
              fi
            fi
          else
            # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π push - –≤—Å–µ–≥–¥–∞ patch increment
            VERSION_TYPE="patch"
            CUSTOM_VERSION=""
            echo "Automatic push trigger - using patch increment"
          fi
          
          echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT
          echo "custom_version=$CUSTOM_VERSION" >> $GITHUB_OUTPUT
          echo "Final outputs - version_type: $VERSION_TYPE, custom_version: $CUSTOM_VERSION"
          
      - name: üìä Calculate version
        if: steps.docker_check.outputs.should_build == 'true'
        id: version
        run: |
          set -e
          echo "Calculating version..."
          
          BRANCH="${GITHUB_REF_NAME}"
          
          # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–µ—Ñ–∏–∫—Å –≤–µ—Ä—Å–∏–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –≤–µ—Ç–æ–∫
          if [ "$BRANCH" = "main" ]; then
            VERSION_PREFIX="v1"
            TAG_PATTERN="v1.*"
          elif [ "$BRANCH" = "gateway" ]; then
            VERSION_PREFIX="v2"
            TAG_PATTERN="v2.*"
          else
            VERSION_PREFIX="v0"
            TAG_PATTERN="v0.*"
          fi
          
          echo "Branch: $BRANCH, Version prefix: $VERSION_PREFIX"
          
          # DEBUG: –ü—Ä–æ–≤–µ—Ä—è–µ–º inputs –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ step
          VERSION_TYPE="${{ steps.version_strategy.outputs.version_type }}"
          CUSTOM_VERSION="${{ steps.version_strategy.outputs.custom_version }}"
          echo "=== VERSION CALCULATION DEBUG ==="
          echo "Received version_type: '$VERSION_TYPE'"
          echo "Received custom_version: '$CUSTOM_VERSION'"
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º custom —Å—Ä–∞–∑—É
          if [ "$VERSION_TYPE" = "custom" ]; then
            if [ -z "$CUSTOM_VERSION" ]; then
              echo "‚ùå Custom version not provided"
              exit 1
            fi
            echo "Using custom version: $CUSTOM_VERSION"
            echo "version=$CUSTOM_VERSION" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –°–¢–ê–ë–ò–õ–¨–ù–´–ô —Ç–µ–≥ –¥–ª—è —Ç–µ–∫—É—â–µ–π –≤–µ—Ç–∫–∏ (–±–µ–∑ -beta, -alpha, -rc)
          # –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–≥–∏ –±–µ–∑ —Å—É—Ñ—Ñ–∏–∫—Å–æ–≤
          LAST_TAG=$(git tag --list "$TAG_PATTERN" | grep -v '\-' | sort -V | tail -n 1)

          if [ -z "$LAST_TAG" ]; then
            echo "No stable tags found for pattern $TAG_PATTERN, starting with ${VERSION_PREFIX}.0.0"
            NEW_VERSION="${VERSION_PREFIX}.0.0"
          else
            echo "Last stable tag found for branch: $LAST_TAG"
            
            # –ü–∞—Ä—Å–∏–º –≤–µ—Ä—Å–∏—é (—É–±–∏—Ä–∞–µ–º —Å—É—Ñ—Ñ–∏–∫—Å—ã —Ç–∏–ø–∞ -beta, -alpha, -rc1)
            CLEAN_VERSION="${LAST_TAG#v}"                    # –£–±–∏—Ä–∞–µ–º 'v'
            CLEAN_VERSION="${CLEAN_VERSION%%-*}"             # –£–±–∏—Ä–∞–µ–º –≤—Å—ë –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ '-'
            IFS='.' read -r MAJOR MINOR PATCH <<<"$CLEAN_VERSION"
            echo "Current version: MAJOR=$MAJOR, MINOR=$MINOR, PATCH=$PATCH (from $LAST_TAG)"
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–æ–≤—É—é –≤–µ—Ä—Å–∏—é
            case $VERSION_TYPE in
              "minor")
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              "patch")
                PATCH=$((PATCH + 1))
                ;;
              *)
                echo "‚ùå Unknown version type: $VERSION_TYPE"
                exit 1
                ;;
            esac
            
            NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          fi
          
          echo "New version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: üîç Check if version exists
        if: steps.docker_check.outputs.should_build == 'true'
        id: version_exists
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          VERSION_TYPE="${{ steps.version_strategy.outputs.version_type }}"

          echo "=== VERSION EXISTENCE CHECK ==="
          echo "Version: $VERSION"
          echo "Version type: $VERSION_TYPE"

          # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Ç–µ–≥
          TAG_EXISTS="false"
          if git rev-parse "$VERSION" >/dev/null 2>&1; then
            TAG_EXISTS="true"
            echo "‚úÖ Git tag $VERSION already exists"
          else
            echo "‚ÑπÔ∏è Git tag $VERSION does not exist yet"
          fi

          # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ release (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ —Ä—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫)
          RELEASE_EXISTS="false"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Checking if GitHub Release exists for $VERSION..."

            # –ú–µ—Ç–æ–¥ 1: gh release view
            if gh release view "$VERSION" >/dev/null 2>&1; then
              RELEASE_EXISTS="true"
              echo "‚úÖ GitHub Release $VERSION found (via gh release view)"
            else
              # –ú–µ—Ç–æ–¥ 2: gh release list
              if gh release list --limit 100 | grep -q "^${VERSION}"; then
                RELEASE_EXISTS="true"
                echo "‚úÖ GitHub Release $VERSION found (via gh release list)"
              else
                # –ú–µ—Ç–æ–¥ 3: GitHub API –Ω–∞–ø—Ä—è–º—É—é
                if curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  "https://api.github.com/repos/${{ github.repository }}/releases/tags/$VERSION" \
                  | grep -q '"tag_name"'; then
                  RELEASE_EXISTS="true"
                  echo "‚úÖ GitHub Release $VERSION found (via GitHub API)"
                else
                  echo "‚ÑπÔ∏è GitHub Release $VERSION does not exist"
                fi
              fi
            fi
          fi

          # –î–ª—è custom –≤–µ—Ä—Å–∏–∏: –µ—Å–ª–∏ —Ç–µ–≥ –∏ release —Å—É—â–µ—Å—Ç–≤—É—é—Ç - —ç—Ç–æ —Ä–µ–∂–∏–º rebuild
          IS_REBUILD="false"
          if [ "$VERSION_TYPE" = "custom" ] && [ "$TAG_EXISTS" = "true" ]; then
            IS_REBUILD="true"
            echo "üîÑ REBUILD MODE: Version exists, will only rebuild Docker images"
            echo "   - Skip tag creation"
            echo "   - Skip release creation"
            echo "   - Only rebuild and push Docker images"
          fi

          echo "tag_exists=$TAG_EXISTS" >> $GITHUB_OUTPUT
          echo "release_exists=$RELEASE_EXISTS" >> $GITHUB_OUTPUT
          echo "is_rebuild=$IS_REBUILD" >> $GITHUB_OUTPUT

      - name: üè∑Ô∏è Check if release needed
        if: steps.docker_check.outputs.should_build == 'true'
        id: release_check
        run: |
          IS_RELEASE_BRANCH="${{ steps.vars.outputs.is_release_branch }}"
          VERSION_TYPE="${{ steps.version_strategy.outputs.version_type }}"
          EVENT_NAME="${{ github.event_name }}"
          SHOULD_CREATE_RELEASE="false"

          echo "=== RELEASE CHECK ==="
          echo "Event: $EVENT_NAME"
          echo "Version type: $VERSION_TYPE"
          echo "Is release branch: $IS_RELEASE_BRANCH"

          # GitHub Release —Å–æ–∑–¥–∞–µ—Ç—Å—è –¢–û–õ–¨–ö–û –¥–ª—è minor –≤–µ—Ä—Å–∏–π –ø—Ä–∏ —Ä—É—á–Ω–æ–º –∑–∞–ø—É—Å–∫–µ
          if [ "$EVENT_NAME" = "workflow_dispatch" ] && [ "$VERSION_TYPE" = "minor" ]; then
            if [ "$IS_RELEASE_BRANCH" = "true" ]; then
              SHOULD_CREATE_RELEASE="true"
              echo "‚úÖ Will create GitHub Release (manual minor version)"
            else
              echo "‚ö†Ô∏è Not a release branch - skipping release"
            fi
          else
            echo "‚ÑπÔ∏è No GitHub Release (only for manual minor versions)"
            echo "   - Event: $EVENT_NAME (need: workflow_dispatch)"
            echo "   - Version type: $VERSION_TYPE (need: minor)"
          fi

          echo "should_create_release=$SHOULD_CREATE_RELEASE" >> $GITHUB_OUTPUT
          
      - name: üìù Generate release body
        if: steps.docker_check.outputs.should_build == 'true' && steps.release_check.outputs.should_create_release == 'true'
        id: release_body
        run: |
          echo "Generating release body for minor version..."

          # –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–∞
          PRODUCT_NAME="${{ steps.vars.outputs.product_name }}"
          VERSION="${{ steps.version.outputs.version }}"

          # –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ release notes –∏–∑ input (–µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω—ã)
          CUSTOM_RELEASE_NOTES="${{ github.event.inputs.release_notes }}"

          # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω —Ç–µ–≥–æ–≤ –¥–ª—è changelog
          BRANCH="${GITHUB_REF_NAME}"
          if [ "$BRANCH" = "main" ]; then
            TAG_PATTERN="v1.*"
          elif [ "$BRANCH" = "gateway" ]; then
            TAG_PATTERN="v2.*"
          else
            TAG_PATTERN="v0.*"
          fi

          # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º changelog (–∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ —Å—Ç–∞–±–∏–ª—å–Ω—ã–µ —Ç–µ–≥–∏ –±–µ–∑ —Å—É—Ñ—Ñ–∏–∫—Å–æ–≤)
          LAST_TAG=$(git tag --list "$TAG_PATTERN" | grep -v '\-' | sort -V | tail -n 1)
          if [ -z "$LAST_TAG" ]; then
            echo "No previous stable tags found for pattern $TAG_PATTERN - generating full changelog"
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges | head -50)
          else
            echo "Generating changelog since stable tag $LAST_TAG"
            CHANGELOG=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          fi

          if [ -z "$CHANGELOG" ]; then
            CHANGELOG="- No changes"
          fi

          # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–ª–æ —Ä–µ–ª–∏–∑–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∏—Å—Ç–æ—á–Ω–∏–∫–∞
          if [ -n "$CUSTOM_RELEASE_NOTES" ]; then
            # –í–∞—Ä–∏–∞–Ω—Ç A: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ release notes + Changelog
            echo "‚úÖ Using custom release notes from workflow input"
            {
              echo "$CUSTOM_RELEASE_NOTES"
              echo ""
              echo "---"
              echo ""
              echo "## üìã Changelog"
              echo ""
              echo "$CHANGELOG"
            } > /tmp/release_body.txt
          else
            # –ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö notes, –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–º–º–∏—Ç
            echo "No custom release notes provided, checking last commit..."

            # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –∫–æ–º–º–∏—Ç
            LAST_COMMIT_FULL=$(git log -1 --pretty=format:"%B")
            COMMIT_LINES=$(echo "$LAST_COMMIT_FULL" | wc -l | tr -d ' ')

            echo "Last commit lines: $COMMIT_LINES"

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ Release Note
            # –£—Å–ª–æ–≤–∏—è: >10 —Å—Ç—Ä–æ–∫ –ò —Å–æ–¥–µ—Ä–∂–∏—Ç markdown –∑–∞–≥–æ–ª–æ–≤–∫–∏ –∏–ª–∏ —Å–ø–∏—Å–∫–∏ —Å —ç–º–æ–¥–∑–∏
            IS_RELEASE_NOTE=false
            if [ "$COMMIT_LINES" -gt 10 ]; then
              if echo "$LAST_COMMIT_FULL" | grep -qE '^(#{1,3} |[-*] |[‚úÖ‚ùåüéØüöÄüêõüìöüîÑüéâ‚ú®üîßüê≥‚öôÔ∏èüìã])'; then
                IS_RELEASE_NOTE=true
                echo "‚úÖ Detected release note in last commit (${COMMIT_LINES} lines, contains markdown)"
              else
                echo "‚ÑπÔ∏è Last commit has ${COMMIT_LINES} lines but no markdown formatting"
              fi
            else
              echo "‚ÑπÔ∏è Last commit is too short (${COMMIT_LINES} lines) - not a release note"
            fi

            if [ "$IS_RELEASE_NOTE" = "true" ]; then
              # –í–∞—Ä–∏–∞–Ω—Ç B: Release Note –∏–∑ –∫–æ–º–º–∏—Ç–∞ + Changelog
              echo "Using release note from commit + changelog"
              {
                echo "$LAST_COMMIT_FULL"
                echo ""
                echo "---"
                echo ""
                echo "## üìã Changelog"
                echo ""
                echo "$CHANGELOG"
              } > /tmp/release_body.txt
            else
              # –í–∞—Ä–∏–∞–Ω—Ç C: –¢–æ–ª—å–∫–æ Changelog (–±–µ–∑ release note)
              echo "Using auto-generated changelog only"
              {
                echo "## ${PRODUCT_NAME} ${VERSION}"
                echo ""
                echo "## üìã Changelog"
                echo ""
                echo "$CHANGELOG"
              } > /tmp/release_body.txt
            fi
          fi

          # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è
          {
            echo "RELEASE_BODY<<EOF"
            cat /tmp/release_body.txt
            echo "EOF"
          } >> $GITHUB_ENV

          echo "‚úÖ Release body generated successfully"

      - name: üßæ Show info
        if: steps.docker_check.outputs.should_build == 'true'
        run: |
          echo "Branch: ${{ github.ref_name }}"
          echo "Base tag: ${{ steps.vars.outputs.base_tag }}"
          echo "Version: ${{ steps.version.outputs.version }}"
          echo "Is release branch: ${{ steps.vars.outputs.is_release_branch }}"
          echo "Should create release: ${{ steps.release_check.outputs.should_create_release }}"
          echo "Should build Docker: ${{ steps.docker_check.outputs.should_build }}"
          echo "Actor: ${{ github.actor }}"
          echo "Event: ${{ github.event_name }}"
          
      - name: üîê Login to Docker Hub
        if: steps.docker_check.outputs.should_build == 'true'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: üîê Login to GitHub Container Registry
        if: steps.docker_check.outputs.should_build == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üîß Build & Push Docker
        if: steps.docker_check.outputs.should_build == 'true'
        run: |
          echo "Building Docker image:"
          echo "Docker Hub:"
          echo " - alexbic/zerotier-sidecar:${{ steps.vars.outputs.base_tag }}"
          echo " - alexbic/zerotier-sidecar:${{ steps.version.outputs.version }}"
          echo "GitHub Container Registry:"
          echo " - ghcr.io/${{ github.repository }}:${{ steps.vars.outputs.base_tag }}"
          echo " - ghcr.io/${{ github.repository }}:${{ steps.version.outputs.version }}"
          docker buildx build \
            --platform linux/amd64 \
            -t alexbic/zerotier-sidecar:${{ steps.vars.outputs.base_tag }} \
            -t alexbic/zerotier-sidecar:${{ steps.version.outputs.version }} \
            -t ghcr.io/${{ github.repository }}:${{ steps.vars.outputs.base_tag }} \
            -t ghcr.io/${{ github.repository }}:${{ steps.version.outputs.version }} \
            --push .

      - name: üè∑Ô∏è Create Git Tag
        if: steps.docker_check.outputs.should_build == 'true' && steps.version_exists.outputs.is_rebuild == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          echo "Creating git tag: $VERSION"

          # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ —Ç–µ–≥
          if git rev-parse "$VERSION" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è Tag $VERSION already exists, skipping tag creation"
          else
            git tag "$VERSION"
            git push origin "$VERSION"
            echo "‚úÖ Tag $VERSION created and pushed"
          fi

      - name: üéØ Create GitHub Release
        if: steps.docker_check.outputs.should_build == 'true' && steps.release_check.outputs.should_create_release == 'true' && steps.version_exists.outputs.is_rebuild == 'false'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: "${{ steps.vars.outputs.product_name }} ${{ steps.version.outputs.version }}"
          body: |
            ${{ env.RELEASE_BODY }}

            ---

            ## üê≥ Docker Images

            **Docker Hub:**
            - `alexbic/zerotier-sidecar:${{ steps.vars.outputs.base_tag }}`
            - `alexbic/zerotier-sidecar:${{ steps.version.outputs.version }}`

            **GitHub Container Registry:**
            - `ghcr.io/${{ github.repository }}:${{ steps.vars.outputs.base_tag }}`
            - `ghcr.io/${{ github.repository }}:${{ steps.version.outputs.version }}`

            ---
            *This release was automatically generated by GitHub Actions*
          draft: false
          prerelease: ${{ steps.vars.outputs.is_prerelease }}
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: ‚úÖ Summary
        if: steps.docker_check.outputs.should_build == 'true'
        run: |
          IS_REBUILD="${{ steps.version_exists.outputs.is_rebuild }}"

          if [ "$IS_REBUILD" = "true" ]; then
            echo "üîÑ Rebuild completed successfully!"
            echo ""
            echo "‚ÑπÔ∏è REBUILD MODE: Version ${{ steps.version.outputs.version }} already exists"
            echo "   - Git tag: already exists (skipped)"
            echo "   - GitHub Release: already exists (skipped)"
            echo "   - Docker images: rebuilt and pushed ‚úÖ"
          else
            echo "üéâ Deployment completed successfully!"
          fi

          echo ""
          echo "üì¶ Docker images pushed to Docker Hub:"
          echo "   - alexbic/zerotier-sidecar:${{ steps.vars.outputs.base_tag }}"
          echo "   - alexbic/zerotier-sidecar:${{ steps.version.outputs.version }}"
          echo ""
          echo "üì¶ Docker images pushed to GitHub Container Registry:"
          echo "   - ghcr.io/${{ github.repository }}:${{ steps.vars.outputs.base_tag }}"
          echo "   - ghcr.io/${{ github.repository }}:${{ steps.version.outputs.version }}"
          echo ""

          if [ "$IS_REBUILD" = "false" ]; then
            echo "üè∑Ô∏è Git tag created: ${{ steps.version.outputs.version }}"
            echo ""

            if [ "${{ steps.release_check.outputs.should_create_release }}" = "true" ]; then
              echo "‚úÖ GitHub Release created: ${{ steps.version.outputs.version }}"
              echo "üîó View release: https://github.com/${{ github.repository }}/releases/tag/${{ steps.version.outputs.version }}"
            else
              VERSION_TYPE="${{ steps.version_strategy.outputs.version_type }}"
              EVENT_NAME="${{ github.event_name }}"
              echo "‚ÑπÔ∏è No GitHub Release created"
              echo "   Reason: Only minor versions create releases"
              echo "   Current: event=$EVENT_NAME, version_type=$VERSION_TYPE"
              echo ""
              echo "üí° To create a release:"
              echo "   1. Go to Actions ‚Üí Deploy Zerotier Sidecar ‚Üí Run workflow"
              echo "   2. Select 'minor' as version type"
            fi
          fi
